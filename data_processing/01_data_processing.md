# data_processing

## 1. 넘파이 (Numpy) - 수치 연산의 핵심

### 1.1. 넘파이 탄생 배경 및 철학

- **문제 상황**:
    - **과학/공학 분야의 요구**: 복잡한 수치 연산 (선형대수, 통계, 미적분 등)을 빠르고 효율적으로 처리해야 했음.
    - **기존 도구의 한계**:
        - **MATLAB**: 강력한 수치 연산 도구이지만, 유료이고 파이썬과의 연동성이 떨어짐.
        - **파이썬**: 유연하고 배우기 쉽지만, 수치 연산 속도가 느리다. (인터프리터 언어, 동적 타입).
- **해결책: 넘파이 (Numerical Python)**
    - **개발자**: 트라비스 올리펀트 (Travis Oliphant) - 과학자, 엔지니어 (현 Anaconda, Quansight 창립자).
    - **목표**: 파이썬의 장점(유연성, 가독성, 풍부한 라이브러리)을 유지하면서 MATLAB 수준의 수치 연산 성능 제공.
    - **핵심 철학**:
        1. **속도 (Speed)**:
            - **C 언어 기반 구현**: 핵심 연산 부분을 C로 작성하여 속도 향상 (파이썬은 인터프리터 언어라 느림).
            - **벡터화 연산 (Vectorization)**: 여러 데이터에 대한 연산을 한 번에 처리 (반복문 없이) → CPU/GPU 병렬 처리 활용 극대화.
        2. **편의성 (Convenience)**:
            - **고수준 추상화**: 복잡한 수치 연산을 추상화하여 간결한 코드로 표현 (예: 행렬 곱셈, 역행렬 계산 등).
            - **배열 기반 프로그래밍**: 데이터를 배열(array) 형태로 다루어 직관적이고 효율적인 연산 가능.
        3. **확장성 (Extensibility)**:
            - **Glue Language**: C/C++, Fortran 등 다른 언어 코드와 쉽게 통합 (기존 라이브러리 활용).
            - **개방성**: 오픈 소스, 다양한 라이브러리와의 연동 (SciPy, Pandas, Matplotlib 등).
        4. **재사용 (Reuse)**:
            - **"바퀴를 다시 발명하지 마라 (Don't reinvent the wheel)"**: 기존에 잘 만들어진 수치 연산 라이브러리(BLAS, LAPACK 등) 활용.

### 1.2 데이터 처리의 중요성
- **데이터 품질 향상**: 불완전하거나 부정확한 데이터를 수정
- **인사이트 발견**: 가공된 데이터를 통해 유용한 패턴 및 관계 발견
- **효율적인 분석**: 정제된 데이터로 분석 시간 단축

## 2. 데이터 처리 단계

### 2.1 데이터 수집(Data Collection)                
```python
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# 벡터화 연산 (각 요소별 덧셈)
c = a + b  # 결과: array([5, 7, 9])

# @np.vectorize 데코레이터: 일반 함수를 벡터화 함수로 변환
@np.vectorize
def add_elements(x, y):
    return x + y

result = add_elements([1, 2, 3], [4, 5, 6])  # 결과: array([5, 7, 9])
```

- **`ndarray` 생성 방법**:
    1. **`np.array()`**: 리스트, 튜플 등 시퀀스 데이터로부터 생성.
        - `dtype` 인자로 데이터 타입 명시 가능 (예: `np.array([1, 2, 3], dtype=np.float32)`).
        - 데이터 타입 혼합 시, 더 큰 범위의 타입으로 자동 변환 (coercion).
    2. **팩토리 함수 (Factory Functions)**: 특정 값/패턴으로 초기화된 배열 생성.
        - `np.zeros(shape)`: 0으로 채워진 배열.
        - `np.ones(shape)`: 1로 채워진 배열.
        - `np.empty(shape)`: 초기화되지 않은 배열 (빠르지만 쓰레기 값 포함 가능).
        - `np.eye(N)`: N x N 단위 행렬 (identity matrix).
        - `np.arange(start, stop, step)`: 범위 내 숫자 시퀀스 생성.
        - `np.linspace(start, stop, num)`: 균등 간격 숫자 시퀀스 생성.
        - `np.random.rand(shape)`: 난수 배열 생성.
        - ... (다양한 팩토리 함수 존재)
    3. **`reshape()`**: 배열의 차원/형태 변경.
- **`ndarray` 속성**:
    - `ndarray.shape`: 배열의 차원별 크기 (튜플).
    - `ndarray.ndim`: 배열의 차원 수 (rank).
    - `ndarray.dtype`: 배열 요소의 데이터 타입.
    - `ndarray.size`: 배열 요소의 총 개수.
    - `ndarray.itemsize`: 배열 요소 하나의 바이트 크기.
    - `ndarray.nbytes`: 배열 전체 데이터의 바이트 크기.

### 1.3. 다차원 배열 시각화 및 이해

- **핵심**: 3차원 이상 배열은 2차원(행렬) 형태로 나눠서 이해하는 것이 직관적.
- **예시**:
    - `(2, 3, 4)`: 3행 4열 행렬이 2개 (또는 2행 4열 행렬이 3개).
    - `(2, 3, 4, 1)`: (4행 1열) 3개가 2개.
- **이미지 데이터**:
    - 흑백: (높이, 너비) - 2차원.
    - 컬러: (높이, 너비, 채널) - 3차원 (채널: RGB).
- **비디오 데이터**: (높이, 너비, 채널, 시간) - 4차원.
- **데이터셋**: (샘플 수, 높이, 너비, 채널, 시간) - 5차원.

### 1.4. 인덱싱과 슬라이싱 (Indexing and Slicing)

- **목적**: 배열의 특정 요소 또는 부분 집합 접근/추출/변경.
- **5가지 방법**:
    1. **기본 인덱싱/슬라이싱**: 파이썬 리스트와 유사.
        - `a[0]`: 첫 번째 요소.
        - `a[1:4]`: 1번 인덱스부터 3번 인덱스까지.
        - `a[-1]`: 마지막 요소.
        - `a[:]`: 전체.
    2. **콤마 인덱싱**: 다차원 배열에서 각 차원별 인덱스/슬라이스 지정.
        - `a[1, 2]`: 1행 2열 요소.
        - `a[0, :]`: 0행 전체.
        - `a[:, 1]`: 1열 전체.
    3. **불린 인덱싱 (Boolean Indexing)**: 조건에 맞는 요소 선택.
        - `a[a > 5]`: 값이 5보다 큰 요소.
        - 불린 배열(마스크) 사용: `a[np.array([True, False, True, False])]`.
        - 조건 배열과 대상 배열의 모양(shape) 일치해야 함.
    4. **팬시 인덱싱 (Fancy Indexing)**: 정수 배열/리스트로 인덱스 지정.
        - `a[[0, 2, 4]]`: 0, 2, 4번 인덱스 요소 선택.
        - 차원 유지, 재구성 가능.
        - 예: `tips[['total_bill', 'tip']]` (Pandas DataFrame에서 열 선택).
    5. **확장 팬시 인덱싱**:
        - `a[[0, 1], [2, 3]]`: (0, 2), (1, 3) 위치 요소 선택.
    6. **`...` (Ellipsis)**: 생략 부호, 나머지 모든 차원 선택.
        - `a[..., 0]`: 마지막 차원의 0번 인덱스 요소 선택.

## 2. 텐서플로우 (TensorFlow) & 파이토치 (PyTorch)

- **공통점**:
    - 넘파이 기반 `ndarray`와 유사한 `Tensor` 객체 제공.
    - GPU 지원 (넘파이는 기본적으로 미지원).
    - 자동 미분 (Automatic Differentiation) 기능: 딥러닝 학습에 필수.
- **차이점**:
    - **추상화 수준**: 텐서플로우/파이토치는 딥러닝에 특화된 기능/API 제공.
    - **API 스타일**: 텐서플로우는 `tf.function`, 파이토치는 `@torch.jit.script` 데코레이터 등.
    - **텐서 생성**: 텐서플로는 `tf.constant`, 파이토치는 `torch.Tensor` 클래스 사용.
    - **`dtype` 지정**: 텐서플로는 `tf.int32`, 파이토치는 `torch.int32` (약간의 차이).

## 3. 기타 주요 개념

- **함수형 프로그래밍 (Functional Programming)**:
    - 불변성(Immutability): 데이터 변경 불가능 → 예측 가능, 디버깅 용이.
    - 순수 함수(Pure Function): 같은 입력에 항상 같은 출력, 부작용(side effect) 없음.
    - 고차 함수(Higher-Order Function): 함수를 인자로 받거나 반환.
    - 합성 함수(Function Composition): 함수들을 결합하여 새로운 함수 생성.
- **데코레이터 (Decorator)**:
    - 함수/클래스 기능을 수정/확장하는 함수.
    - `@` 기호 사용 (Syntactic Sugar).
    - 예: `@tf.function`, `@torch.jit.script`, `@np.vectorize`, `@abstractmethod`.
    - 파라미터 있는 데코레이터: 3중 중첩 함수 또는 `functools.partial` 사용.
- **메타클래스 (Metaclass)**:
    - 클래스의 클래스 (클래스 행동 제어).
    - `type`이 기본 메타클래스.
    - 싱글톤(Singleton) 패턴, 상속 제한 등에 사용.
- **추상화 (Abstraction)**:
    - **추상 클래스 (Abstract Class)**: 인스턴스 생성 불가, 추상 메서드 포함 가능.
    - **추상 메서드 (Abstract Method)**: `@abstractmethod` 데코레이터, 하위 클래스에서 반드시 구현.
    - **덕 타이핑 (Duck Typing)**: 객체 타입보다 메서드/속성 존재 여부로 판단.
- **`with` 문**:
    - 컨텍스트 관리자 (Context Manager) 사용.
    - `__enter__()`, `__exit__()` 메서드 구현.
    - 자동 자원 관리 (예: 파일 닫기).
- **시그니처 (Signature)**: 함수/메서드의 입력/출력 타입 정보 (`inspect.signature()`).
- **`repr` vs. `str`**:
    - `__repr__()`: 객체의 공식적인 표현 (개발자/디버깅).
    - `__str__()`: 객체의 비공식적인 표현 (사용자/출력).
- **클로저 (Closure)**: 함수 내부 함수가 외부 함수 변수(자유 변수) 접근.
    - `nonlocal`: 외부 변수 수정.
    - `codeobject.co_freevars`: 클로저 변수 이름.

## 4. NumPy 소개: 왜 NumPy인가?

- **NumPy의 역할:**
    - Numerical Python의 약자로, **수치 계산**을 위한 파이썬 라이브러리.
    - 공학, 통계 등 수를 다루는 학문에서 복잡한 연산을 컴퓨터를 통해 효율적으로 수행하기 위해 사용.
    - MATLAB과 같은 상용 도구의 대안으로, 파이썬의 장점(다양한 문법, 표현력, 뮤터블 데이터 타입 등)을 활용하면서 수치 계산을 수행할 수 있도록 함.
- **NumPy 이전의 시도와 실패:**
    - MATLAB과 같은 기능을 파이썬에서 구현하려는 시도는 이전에도 많았지만, 대부분 실패.
    - **실패 원인:** 파이썬의 느린 실행 속도 (C보다 100배 느림).
    - **해결책 모색:**
        - **하드웨어 활용:** GPU, 멀티 프로세서 등을 사용하여 컴퓨팅 파워를 높이는 방법 (비용 문제).
        - **컴파일러 활용:** JIT(Just-In-Time) 컴파일러 등을 사용하여 실행 속도를 개선하는 방법 (PyPy 등, 호환성 문제).
        - **C 언어와의 결합:** 파이썬의 확장/내장 기능을 활용하여, 실행 속도가 느린 부분을 C로 구현하고 파이썬에서 호출하는 방법 (Glue).
- **NumPy의 성공 요인:**
    - **C 언어 기반:** 실행 속도가 느린 부분을 C로 구현하여 성능을 향상시켰음.
    - **벡터화 연산(Vectorization):** 여러 개의 데이터를 한 번에 연산하는 방식으로, 하드웨어(CPU, GPU)의 병렬 처리 기능을 활용하여 속도를 높임.
    - **Homogeneous 데이터 구조:** 모든 데이터가 동일한 타입(주로 숫자)으로 구성된 배열(array)을 사용하여 메모리 접근 및 연산 효율성을 높임.
    - **전문가를 위한 기능:** 다양한 수학적 함수와 선형대수 연산을 지원하여, 복잡한 수치 계산을 쉽게 수행할 수 있도록 함.

## 5. NumPy의 핵심 개념: ndarray

- **ndarray (N-dimensional array):**
    - NumPy의 핵심 데이터 구조로, **다차원 배열**을 나타냄.
    - 수학적 개념으로는 **텐서(tensor)**, 프로그래밍 관점에서는 **멀티 디멘션 어레이(multi-dimensional array)** 라고도 함.
    - **특징:**
        - **Homogeneous:** 모든 요소가 동일한 데이터 타입(dtype)을 가짐.
        - **Shape:** 배열의 차원과 각 차원의 크기를 나타내는 튜플입니다. (예: (2, 3)은 2행 3열의 2차원 배열)
        - **Vectorization:** 배열의 각 요소에 대해 동일한 연산을 한 번에 수행할 수 있음.
- **ndarray와 array.array 비교:**
    - **array.array:** 파이썬의 내장 모듈로, homogeneous한 시퀀스 데이터 구조를 제공.
    - **차이점:**
        - **수학적 연산:** array.array는 시퀀스 데이터 타입의 연산(이어붙이기 등)을 수행하는 반면, ndarray는 수학적 연산(덧셈, 곱셈 등)을 지원.
        - **성능:** ndarray는 C로 구현되어 있고 벡터화 연산을 지원하여 array.array보다 훨씬 빠름.

## 6. NumPy와 다른 라이브러리(TensorFlow, PyTorch)

- **NumPy의 한계:**
    - **GPU 지원 부족:** 기본적으로 GPU를 지원하지 않아, 딥러닝과 같이 대규모 연산이 필요한 작업에는 비효율적.
    - **딥러닝 특화 기능 부족:** 딥러닝 모델 학습에 필요한 자동 미분(automatic differentiation) 등의 기능을 제공하지 않음.
- **TensorFlow, PyTorch의 등장:**
    - NumPy의 한계를 극복하고 딥러닝 모델 개발을 지원하기 위해 등장.
    - **핵심:** NumPy의 ndarray와 유사한 **텐서(tensor)** 라는 데이터 구조를 제공하며, GPU를 지원하고 자동 미분 등의 기능을 추가.
    - **NumPy와의 관계:** NumPy를 기반으로 만들어졌기 때문에, NumPy를 알면 TensorFlow, PyTorch의 텐서를 쉽게 이해하고 사용 가능.

## 7. NumPy 시작하기: ndarray 생성 및 기본 조작

- **ndarray 생성 방법:**
    1. **`np.array()`:** 리스트, 튜플 등 파이썬 시퀀스 데이터를 ndarray로 변환.
        
        ```python
        import numpy as np
        
        a = np.array([1, 2, 3])  # 1차원 배열
        b = np.array([[1, 2, 3], [4, 5, 6]])  # 2차원 배열
        ```
        
    2. **팩토리 함수:** 특정 값을 가지는 ndarray를 생성하는 함수 (예: `np.zeros()`, `np.ones()`, `np.eye()`, `np.arange()`, `np.linspace()` 등).
        
        ```python
        zeros = np.zeros((2, 3))  # 0으로 채워진 2x3 배열
        ones = np.ones((3, 3))  # 1로 채워진 3x3 배열
        eye = np.eye(3)  # 단위 행렬
        arange = np.arange(10)  # 0부터 9까지의 숫자를 가지는 1차원 배열
        linspace = np.linspace(0, 1, 5)  # 0부터 1까지 균등한 간격으로 5개의 숫자를 가지는 배열
        ```
        
    3. **`reshape()`:** 기존 ndarray의 shape을 변경.
        
        ```python
        a = np.arange(12)
        b = a.reshape(3, 4)  # 3x4 배열로 변경
        ```
        
- **ndarray의 속성:**
    - **`shape`:** 배열의 차원과 크기를 나타내는 튜플.
    - **`ndim`:** 배열의 차원 수.
    - **`dtype`:** 배열 요소의 데이터 타입.
    - **`size`:** 배열 요소의 총 개수.
- **데이터 타입 변환 (Coercion):**
    - NumPy는 homogeneous 데이터 구조를 유지하기 위해, 다른 타입의 데이터를 입력하면 **묵시적 형변환(coercion)** 을 수행.
    - **주의:** 문자열과 숫자를 함께 사용하면, NumPy는 문자열로 변환하지만, TensorFlow, PyTorch는 오류를 발생시킴.
- **`repr()` vs `str()`:**
    - **`repr()`:** 객체의 공식적인 표현(representation)을 반환. (ndarray의 경우, `array(...)` 형태로 출력)
    - **`str()`:** 객체의 비공식적인 표현(string)을 반환. (ndarray의 경우, 대괄호 안의 숫자만 출력)
    - **권장:** `repr()`을 사용하여 ndarray의 구조를 명확하게 확인하는 것이 좋음.

## 8. 다차원 배열의 이해

- **3차원 이상의 배열:**
    - 직관적으로 이해하기 어렵기 때문에, 2차원 배열을 쌓아 올리는 방식으로 이해하는 것이 좋음.
    - **예:** (2, 3, 4) shape의 3차원 배열은 3행 4열의 2차원 배열이 2개 쌓여 있는 것으로 생각할 수 있다.
    - **보는 관점:** 보는 방향에 따라 행, 열, 높이의 개념이 달라질 수 있다.
- **차원 축소(Reduction):**
    - 배열의 특정 축(axis)을 따라 연산을 수행하여 차원을 줄이는 방법.
    - **예:** `np.sum(axis=0)`은 0번 축(행)을 따라 합계를 계산하여 2차원 배열을 1차원 배열로 축소.
    - **핵심:** 데이터의 특성을 유지하면서 차원을 줄이는 것이 중요.

## 9. 인덱싱과 슬라이싱

- **NumPy의 5가지 인덱싱/슬라이싱 방법:**
    1. **콤마 인덱싱:** 각 차원의 인덱스를 콤마(,)로 구분하여 지정. (예: `a[1, 2]`)
    2. **불린 인덱싱:** True/False 값을 가지는 배열을 사용하여 조건에 맞는 요소만을 선택. (예: `a[a > 3]`)
    3. **팬시 인덱싱(Fancy Indexing):** 정수 배열을 사용하여 여러 개의 요소를 한 번에 선택. (예: `a[[1, 3, 5]]`)
        - **특징:** 차원을 유지하고, 요소의 순서 변경 가능.
    4. **팬시 인덱싱 확장:** 콤마를 사용하여 행과 열에 각각 팬시 인덱싱을 적용. (예: `a[[1, 2], [3, 4]]`)
    5. **`...` (Ellipsis):** 생략 부호(...)를 사용하여 나머지 모든 차원을 선택. (예: `a[..., 1]`)
- **3차원 배열에서의 인덱싱/슬라이싱 연습:**
    - 다양한 인덱싱/슬라이싱 방법을 사용하여 3차원 배열의 특정 요소를 선택하고, 그 결과를 직관적으로 이해하는 연습이 필요.
    - **예:**
        
        ```python
        a = np.arange(24).reshape(2, 3, 4)
        
        # 5를 선택
        a[0, 1, 1]
        
        # [4, 5, 6, 7]을 선택
        a[0, 1, :]
        
        # [0, 12]를 선택
        a[:, 0, 0]
        
        # [5, 6, 17, 18]을 선택
        a[:, 1:2, 1:3]  # 또는 a[:, 1, 1:3]
        ```

## 10. `repr` vs `str` 심화

- 객체를 문자열로 표현하는 두 가지 방식.
- `repr`: 객체를 **개발자 관점**에서 표현. 객체의 생성 방법 등 상세한 정보를 포함하여, `eval()` 함수를 통해 객체를 다시 생성할 수 있도록 표현하는 것이 목표.
- `str`: 객체를 **사용자 관점**에서 표현. 객체의 내용 등 가독성이 좋고 이해하기 쉬운 형태로 표현하는 것이 목표.
- NumPy, TensorFlow 등에서는 `repr` 출력 시 데이터 타입, shape 등 상세 정보를 함께 제공.

## 11. 기본 연산 (Basic Operations) 및 벡터화 (Vectorize)

- NumPy, TensorFlow 등은 기본적인 사칙연산(+, -, \*, /)을 지원하며, 이는 **벡터화 연산** 방식으로 수행됨.
- **벡터화 연산**: 각 요소별로 연산이 독립적으로, 병렬적으로 빠르게 처리됩니다. 별도의 프로세스에서 작동하며, 사용자는 수학적 컨셉만 이해하면 됨.
- 연산자 오버로딩을 통해 (+, -, *, /, @ 등) 연산자를 사용하며, 각 연산자에는 대응하는 함수(`np.add`, `np.subtract`, `np.multiply`, `np.dot` 등) 또는 메서드(`__add__`, `__mul__` 등)가 존재.
- `@`: 행렬곱 연산 (NumPy, TensorFlow).
- `dot()`: 내적 연산 (NumPy). 차원에 따라 연산 결과가 달라진다.

## 12. 인덱싱과 슬라이싱 심화

- **콤마 인덱싱**: 다차원 배열에서 각 차원에 대한 인덱싱을 `,`로 구분하여 사용. 예: `a[0, 1]` (1차원 인덱스 0, 2차원 인덱스 1인 요소 선택).
- **불린 인덱싱**: True/False 값을 가지는 배열을 사용하여 True에 해당하는 요소만 선택.
- **팬시 인덱싱 확장**:
    - `:`: 해당 차원의 모든 요소를 선택.
    - `...` (Ellipsis): 생략된 차원(들)의 모든 요소를 선택.
    - `None`, `np.newaxis`: 새로운 차원을 추가. 차원 추가 위치에 따라 행 또는 열을 추가할 수 있음.
    - `tf.newaxis`: TensorFlow에서도 동일한 기능을 제공.

## 13. 차원(Dimension)과 Shape

- 데이터의 구조를 나타내는 중요한 개념.
- **차원**: 데이터가 몇 단계로 중첩되어 있는지를 나타냄 (예: 1차원 배열, 2차원 배열, 3차원 배열).
- **Shape**: 각 차원의 크기를 나타냄 (예: (2, 3, 4)는 3차원 배열이며, 각 차원의 크기는 2, 3, 4).
- 3차원 이상의 데이터 구조는 인간이 직관적으로 이해하기 어렵지만, 익숙해지면 다룰 수 있음.
- `reshape()`: 배열의 shape을 변경.
- `T`: 전치(Transpose) 연산. 행과 열을 바꿈.
- 연산의 기본은 shape이 같아야 함. `None`, `np.newaxis`를 사용하여 shape을 맞출 수 있음.

## 14. 절대값 vs 상대값

- 데이터 분석에서 중요한 개념.
- **절대값**: 데이터 값 자체를 의미.
- **상대값**: 다른 데이터와의 비교를 통해 나타나는 값 (예: 비율, 변화율).
- 분석가의 역량 중 하나는 데이터의 절대치와 상대치를 파악하고 적절히 활용하는 것.

## 15. `as`, `from`, `to`, `like` 키워드

- 데이터 변환과 관련된 키워드들.
- **`as`**:
    - `import ... as ...`: 모듈/패키지를 불러올 때 별칭을 지정. 충돌 방지, 가독성 향상 등의 목적으로 사용.
    - `with ... as ...`: 컨텍스트 매니저를 사용할 때, 컨텍스트 객체를 변수에 할당.
    - `except ... as ...`: 예외 처리 시, 예외 객체를 변수에 할당.
    - `astype()`: 데이터 타입을 변환. (NumPy, Pandas)
    - `asarray()`: 입력 데이터를 NumPy 배열로 변환. (NumPy)
- **`from`**:
    - `from ... import ...`: 모듈/패키지의 특정 요소(함수, 클래스, 변수 등)를 불러옴
    - `from ... import *`: 모듈/패키지의 모든 요소(\_\_all\_\_에 정의된)를 불러옴. (\_로 시작하는 요소는 제외)
    - `yield from ...`: 제너레이터에서 다른 제너레이터의 값을 yield할 때 사용.
    - `raise ... from ...`: 예외 발생 시, 다른 예외를 함께 발생시킴.
    - `from_...()`: 특정 자료구조에서 DataFrame/배열/텐서를 생성. (Pandas, NumPy, PyTorch)
- **`to`**:
    - `to_...()`: 다른 자료구조로 변환. (Pandas, PyTorch)
- **`like`**:
    - `..._like()`: 다른 배열/텐서와 동일한 shape과 데이터 타입을 가지는 새로운 배열/텐서를 생성. (NumPy, PyTorch)

## 16. ufunc (Universal Function)

- NumPy에서 제공하는 함수로, 다양한 데이터 타입에 대해 범용적으로 사용할 수 있는 함수.
- `np.add`, `np.subtract`, `np.multiply` 등 사칙연산 함수들이 ufunc에 해당.

## 17. 브로드캐스팅 (Broadcasting)

- NumPy, TensorFlow, PyTorch에서 shape이 다른 배열/텐서 간의 연산을 가능하게 하는 메커니즘.
- 특정 규칙에 따라 작은 배열/텐서가 큰 배열/텐서의 shape에 맞춰 자동으로 확장되어 연산 수행.
- 브로드캐스팅 규칙을 이해하고 활용하면 코드를 간결하게 작성하고 연산 효율성을 높일 수 있음.

## 18. 라이브러리 간 호환성

- NumPy, TensorFlow, Pandas 등은 서로 호환되는 기능을 제공.
- `__array__` 속성: NumPy와 호환되는 객체임을 나타냄.
- NumPy 배열을 TensorFlow 텐서로 변환하거나 (`tf.add(np_array, np_array)`), TensorFlow 텐서를 NumPy 배열로 변환(`np.add(tf_tensor, tf_tensor)`)할 수 있음.

## 19. 유용한 도구들

- `sys.path`: Python 모듈 검색 경로.
- `dir()`: 객체의 속성 및 메서드 목록을 반환.
- `%whos`: 현재 정의된 변수 목록과 정보를 출력.
- `help()`, `np.info()`, `np.lookfor()`: 함수/모듈에 대한 도움말을 제공.
- `scipy`: NumPy 기반의 과학 기술 연산을 위한 라이브러리.
